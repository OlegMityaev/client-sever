\section{Алгоритмы работы клиентской и серверной частей при функционировании по протоколу UDP}

\subsection{Алгоритм работы клиентской части}

Инициализация UDP-клиента выполняется следующим образом. Создаётся UDP-сокет типа SOCK_DGRAM с использованием функции socket. Настраивается адрес сервера: устанавливается семейство адресов AF_INET, порт преобразуется в сетевой порядок байтов функцией htons, IP-адрес преобразуется из строкового представления в бинарный формат функцией inet_pton. Инициализируется счётчик запросов requestCounter со значением 1 для генерации уникальных идентификаторов запросов.

Обработка команд пользователя выполняется в цикле. Клиент читает команду из стандартного ввода. Для каждой команды формируется соответствующий запрос с уникальным идентификатором requestId, который получается путём инкремента счётчика requestCounter. Команда help обрабатывается локально без обращения к серверу. Команды input и load выполняют чтение графа, валидацию и формирование полезной нагрузки для команды UploadGraph. Команда query формирует запрос PathQuery с указанием начальной и конечной вершин. Команда exit формирует запрос Exit и завершает работу клиента.

Механизм надёжной доставки реализуется функцией sendUdpWithAck. Алгоритм отправки запроса с подтверждением работает следующим образом. Формируется пакет, содержащий сериализованный заголовок сообщения и полезную нагрузку. Выполняется до 3 попыток отправки пакета на сервер с использованием функции sendto. После каждой отправки клиент ожидает ответа от сервера в течение 3 секунд, используя функцию select для проверки готовности сокета к чтению. Если в течение таймаута ответ не получен, выполняется следующая попытка отправки. Если все 3 попытки неудачны, клиент сообщает о потере связи с сервером и прекращает работу.

Обработка ответа от сервера выполняется следующим образом. Клиент получает датаграмму от сервера функцией recvfrom. Проверяется размер полученных данных: если размер меньше размера заголовка, пакет игнорируется. Десериализуется заголовок сообщения из первых 12 байт полученных данных. Извлекается полезная нагрузка из оставшихся байт. Проверяется соответствие идентификатора requestId в ответе идентификатору отправленного запроса. Если получена команда Ack с совпадающим requestId, клиент ожидает ответное сообщение с данными в течение 3 секунд. Если получено сообщение с данными (не Ack), оно обрабатывается как ответ на запрос. Если ответ содержит команду Error, Help, PathResult или UploadGraph, вызывается функция processResponse для обработки ответа и вывода результата пользователю.

\subsection{Алгоритм работы серверной части}

Инициализация UDP-сервера выполняется следующим образом. Создаётся UDP-сокет типа SOCK_DGRAM с использованием функции socket. Настраивается адрес сервера: устанавливается семейство адресов AF_INET, адрес привязывается ко всем интерфейсам (INADDR_ANY), порт преобразуется в сетевой порядок байтов функцией htons. Сокет привязывается к адресу функцией bind. Инициализируется хеш-таблица clients для хранения состояния графа каждого клиента, где ключом является строка вида "IP:порт", а значением структура ClientContext, содержащая граф и флаг наличия графа. Инициализируется мьютекс clientsMutex для синхронизации доступа к хеш-таблице клиентов.

Основной цикл обработки запросов работает следующим образом. Сервер ожидает входящие датаграммы от клиентов, используя функцию recvfrom с буфером размером 65536 байт. При получении датаграммы извлекается адрес отправителя (IP-адрес и порт клиента). Проверяется размер полученных данных: если размер меньше размера заголовка (12 байт), пакет игнорируется. Десериализуется заголовок сообщения из первых 12 байт полученных данных. Извлекается полезная нагрузка из оставшихся байт. Немедленно отправляется подтверждение (ACK) клиенту с использованием функции sendUdpAck, которая формирует сообщение с командой Ack и идентификатором requestId, соответствующим идентификатору полученного запроса.

Обработка команд выполняется после отправки ACK. Формируется ключ клиента из его адреса в формате "IP:порт" функцией addrToKey. Получается или создаётся контекст клиента из хеш-таблицы clients с использованием мьютекса для синхронизации доступа. В зависимости от типа команды в заголовке выполняется соответствующая обработка.

Для команды Help формируется ответное сообщение с текстом справки, устанавливается команда Help и статус Ok в заголовке ответа.

Для команды UploadGraph выполняется десериализация полезной нагрузки графа функцией decodeGraphPayload. Проверяется корректность данных графа и выполняется валидация. Если граф корректен, он сохраняется в контексте клиента, устанавливается флаг hasGraph в значение true, формируется ответное сообщение с подтверждением приёма графа, устанавливается команда UploadGraph и статус Ok в заголовке ответа. Если граф некорректен, формируется ответное сообщение об ошибке с описанием проблемы, устанавливается команда Error и статус InvalidRequest в заголовке ответа.

Для команды PathQuery выполняется десериализация полезной нагрузки запроса пути функцией deserializePathQuery. Проверяется наличие загруженного графа в контексте клиента. Если граф не загружен, формируется ответное сообщение об ошибке с соответствующим описанием. Если граф загружен, выполняется поиск кратчайшего пути алгоритмом Беллмана-Форда функцией bellmanFord с указанием начальной и конечной вершин из запроса. Формируется ответное сообщение с результатом поиска пути функцией buildPathResultPayload. Если путь найден, устанавливается команда PathResult и статус Ok в заголовке ответа, в полезной нагрузке передаётся длина пути и последовательность вершин. Если путь не найден, устанавливается команда Error и статус NotReady в заголовке ответа, в полезной нагрузке передаётся сообщение об ошибке.

Для команды Exit удаляется контекст клиента из хеш-таблицы clients, формируется ответное сообщение с прощальным текстом, устанавливается команда Exit и статус Ok в заголовке ответа.

Для неизвестной команды формируется ответное сообщение об ошибке с описанием, устанавливается команда Error и статус InvalidRequest в заголовке ответа.

Отправка ответа клиенту выполняется функцией sendUdpMessage. Формируется пакет, содержащий сериализованный заголовок ответа и полезную нагрузку. Пакет отправляется клиенту по адресу, извлечённому из полученной датаграммы, с использованием функции sendto. Если отправка не удалась, выводится сообщение об ошибке, но обработка продолжается для других клиентов.

Сервер работает в одном потоке, обрабатывая запросы от всех клиентов последовательно. Состояние графа для каждого клиента хранится независимо в хеш-таблице, что позволяет серверу обслуживать множество клиентов одновременно без смешивания их данных.

